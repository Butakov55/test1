1. Типы данных: примитивные и ссылочные
примитивы хранятся в стэке, они не могут быть объектами.
обертки есть у любого примитива.
Обертки используются в коллекциях, потому что примитивы нельзя использовать в коллекциях.
2. Боксинг - автоматическое привидение примитива к обертке, Анбоксинг - наоборот.
3. Ссылочные типы данных
при создании СТД ссылка хранится в тэке, сам объект в хипе.
чтобы создать СТД нужно использовать оператор new.
Память для неиспользуемых объектов высвобождать не нужно, так как за это отвечает garbage collector.
4. Инкапсуляция.
смысл в том, что объединяем данные и методы в единый объект, есть возможность скрыть внутренню реализацию.
Сокрытие внутренней реализации позволяет легко производить изменения внутри класса.
5. Конструктор, метод
Конструктор должен именовываться как сам класс.
Конструктор вызывается после оператора new.
Метод можно переопределить, конструктор - нальзя.
Конструктор можно перегрузить.
6. This
можно ли присвоить null? Нельзя, потому что в этом случае объект должен потерять ссылку на себя...
7. Разница между интерфейсами и абстрактными классами
Абстрактный класс можент нести в себе какое-то состояние, иметь поля, конструкторы, методы.
Наследоватья можем от одного класса, а реализовывать мы можем много интерфейсов,
Интерфейс - это контракт, список методов, которые должен будет реализовать класс.
Интерфейс используется при создании разных вещей
8. JRE - JVM + набор стандартных классов (JRE достаточно, чтобы запустить джарник)
JDK = JRE + компилятор + еще инструменты
9. Класс Оbject.
Любой класс java наследуется от класса object, это базовый класс для всех классов.
toString() - Возвращает строковое представление объекта
hashCode(), equals(Object obj) - Пара методов, которые используются для сравнения объектов
getClass() - Возвращает специальный объект, который описывает текущий класс
notify(), notifyAll(), wait() - Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей
finalize() - Метод позволяет «освободить» родные не-Java ресурсы: закрыть файлы, потоки и т.д.
clone() - Метод позволяет клонировать объект: создает дубликат объекта

Если мы переопределяем hashCode(), то должны переопределить и equals().
equals() для двух объектов возвращает true, hashCode() также должен возвращать для них одно и то же число.
При этом неравные между собой объекты могут иметь одинаковый hashCode.

10. ООП
Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Полиморфизм - один интерфейс, много реализаций.
полиморфизм позволяет легко менять реализацию, если будут какие-то изменения, позволяет работать с разными типами данных.

Абстрактные классы и интерфейсы.
набор сущности - птицы
набор сущности - летательные аппараты
общее поведение - летать, используем интерфес, если поведение+характеристики - абстрактный класс

11. Коллекциия
ArrayList - это array или list? это array, но у него есть интерфейс List, которые дает возможность использовать его методы

ArrayList - это список на основе массива. LinkedList - связанный список на основе элементов и связи между ними.
В качестве LinkedList лучше всего подходит представление вагонов поезда сцепленных последовательно.
ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время.
Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того в ArrayList нет дополнительных расходов на хранение связки между элементами.
Минусы в скорости вставки/удаления элементов находящихся не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.
LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу
производятся перебором с начала или конца (смотря что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.
Одним словом - если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList

12.SOLID
принципы:
 - единой ответственности
 класс, включает в себя много методов. Его можно разделить логически на подклассы (заказы, хранилище, отображение заказов).
 Следовательно, если нужно внести изменение, то мы будем это делать в одном классе, где логика одна, потенциально это будет безопаснее + логически это понятней.
 - открытости/закрытости
каждый метод класса должен быть открыт для расширения, но закрыт для модификации, нельзя переписывать метод (проще создать новый класс и метод)
 - подстановки лисков
 Объекты в программе могут быть заменены их наследниками без изменения свойств программы.
 есть базовый класс для подсчета площади треугольника, есть класс наследник для подсчета площади квадрата, поведение разное, значит в этом случае нельзя использовать этот принцип,
 потому что поведение разное, поведение должно быть одинаково
 - разделение интерфейсов
 не должно быть интерфейсов с множеством методов, лучше разделить интерфейсы
 - инверсия зависимостей
 зависимости внутри системы строятся на основе абстракций
 Под этим имеется в виду, что не нужно пользоваться классами напрямую, а вместо этого получать готовые объекты как внешнюю зависимость.

 13. Паттерны автоматизации.
 Одиночка или синглтон.
 - это паттерн  проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
 Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.
 1. Гарантирует наличие единственного экземпляра класса
 2. Предоставляет глобальную точку доступа
 Чаще всего встречается в классах конфигурации.
 Есть приватный конструктор, точка доступа через статический метод, если экземпляр не создан, то создаем и возвращаем или возвращаем раннее созданный.

 Строитель или билдер
 - это попрождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель дает возможность использовать один и тот же код строительства для
 получения разных представлений объектов.
 Вызываем билдер, создает экземпляр объекта с нужными параметрами, часто используется в апи-тестах.
 OR
 билдер- построение большого объекта, не используя обязательно все поля, которые нужно заполнить.

 Декоратор
 - это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные "обертки"
 Как пример, разные аннотации, также можно добавлять свои аннотациии.
 OR
 изменение поведения логики теста, при этом не меняя содержимое теста.

 Фасад или Фабрика
 - это структурный паттерн проектирования, который представляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
 пример: есть класс с настройками удаленного запуска на разных браузерах, есть открытый метод, который делает запрос к веб-драйверу,
 остальные методы по настройке  веб-драйверы закрытые (приватные)

 Наблюдатель
 - это поведенческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

 Итератор
 - это поведенческий паттерн проектирования, который дает возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления
 по коллекциям мы обычно проходим итератором.

 Page Object - один из наиболее полезных и используемых архитектурных решений в автоматизации.
 Данный шаблон проектирования помогает инкапсулировать работу с отдельными элементами страницы, что позволяет уменьшить количество кода и его поддержку.
 Если, к примеру, дизайн одной из страниц изменён, то нам нужно будет переписать только соответствующий класс, описывающий эту страницу.
 Основные преимущества:
 - Разделение кода тестов и описания страниц
 - Объединение всех действий по работе с веб-страницей в одном месте

 Data Driven Test
 - Суть паттерна - выполняем тест на основе заданных параметров, запуск одного теста с разными параметрами, иначе говоря - параметризация

 Сериализация — это преобразование объекта или дерева объектов в какой-либо формат с тем, чтобы потом эти объекты можно было восстановить из этого формата.
 Используется, например, для сохранения состояния программы (то есть, некоторых её объектов) между запусками.
 Или для передачи данных между различными экземплярами программы (или различными программами), например, по сети.
 Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить
 на диск или передать другому процессу или, например, по сети, в отличие от самого объекта.
 А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.
 JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком.
 Пример: если у вас есть класс
 class Test
 {
     int length;
     String name;
     public Test(int length, String name)
     {
         this.length = length;
         this.name = name;
     }
 }
 Объект этого класса в сериализованной форме может иметь вид
 { "length": 25, "name": "Имя" }
 Саму сериализацию (и десериализацию) можно производить вручную, или пользоваться соответствующими библиотеками/фреймворками.
 Существуют и бинарные форматы сериализации.


 API - Application programming interface
- способ взаимодействия одной программы с другой.

как работает api
- вызов опреации
- входные данные
- выходные данные

Модель OSI.
1. физический уровень (уровень проводов)
2. канальный уровень (идентификация)
3. сетевой
4. Транспортный
5. Сеансовый
6. Уровень представления
7. прикладной




